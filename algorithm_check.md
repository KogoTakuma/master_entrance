# アルゴリズムとデータ構造 チェックシート

## 計算量
### 各記法のまとめ
### 計算量のオーダーの比較
$`const`$ $`n!`$ $`nlogn`$ $`logn`$ $`n^a`$ $`a^n`$
### 計算量
最悪、平均、最善を求める場合
時間(回数)、空間を求められているのかに注意
## ソート
### バブルソート
既にソートされた箇所は範囲に含めなくて良い
計算量$`O(N^2)`$, 安定なソートアルゴリズム, 交換回数を反転数、転倒数といい、列の乱れを表す値である。
### 選択ソート
安定でないアルゴリズム
### 挿入ソート
計算量$`O(N^2)`$, 安定なソートアルゴリズム, 元のデータがあるていどそーとされている場合計算量が少なくなる
### ヒープソート
ヒープの項参照
### マージソート
計算量$`O(n\log n)`$,安定なソートアルゴリズム、一時的なメモリが必要
分割と統合にアルゴリズムが分かれる。長さ$`n_1`$,$`n_2`$の配列に必要な計算量が、$`O(n_1+n_2)`$
それを再帰的に行うから、$`O(n\log n)`$
### クイックソート
安定なアルゴリズムではない。
適切な基準の選び方なら$`O(n\log n)`$
最悪の場合は$`O(n^2)`$
追加のメモリを使わない
### バケットソート(計数ソート) 要復習
1~kの配列に出現する数を記録してから、累積和を求める。
元の配列を後ろから走査し、その値が記録されている累積和のところを見る。
累積和の値が新しい出力のindexとなる。

安定。$`O(n+k)`$
### 基数ソート

## データ構造

### 配列
### リスト
### スタック
### キュー
### ハッシュテーブル

## 木
### 木を表すデータ構造
### 二分探索木
### ヒープ
### 平衡木
### [AVL木](https://daeudaeu.com/avl_tree/)
### b*木

## グラフ探索
### 幅優先探索
### 深さ優先探索
### 最短経路問題(ベルマンフォード法,ダイクストラ法)
### A*

## 動的計画法
### ナップサック問題
### [最長共通部分系列問題](https://naoya-2.hatenadiary.org/entry/20090328/1238251033)

