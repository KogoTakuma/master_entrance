# アルゴリズムとデータ構造 チェックシート

## 計算量
### 各記法のまとめ
### 計算量のオーダーの比較
$`const`$ $`n!`$ $`nlogn`$ $`logn`$ $`n^a`$ $`a^n`$
### 計算量
最悪、平均、最善を求める場合
時間(回数)、空間を求められているのかに注意
## ソート
### バブルソート
既にソートされた箇所は範囲に含めなくて良い
計算量$`O(N^2)`$, 安定なソートアルゴリズム, 交換回数を反転数、転倒数といい、列の乱れを表す値である。
### 選択ソート
安定でないアルゴリズム
### 挿入ソート
計算量$`O(N^2)`$, 安定なソートアルゴリズム, 元のデータがあるていどそーとされている場合計算量が少なくなる
### ヒープソート
ヒープの項も参照

添字が**1~N**の配列Aを考える。
配列の先頭からヒープを構成していく。なおヒープは親がA[i]とすると、子はA[2i],A[2i+1]というように
対応している。そして、ヒープが完成したら、根を外部に取り出しmヒープを再構成する。そして、配列の最後尾に取り出した値を戻す。
平均、最悪共に$`O(n\log n)`$

### マージソート
計算量$`O(n\log n)`$,安定なソートアルゴリズム、一時的なメモリが必要
分割と統合にアルゴリズムが分かれる。長さ$`n_1`$,$`n_2`$の配列に必要な計算量が、$`O(n_1+n_2)`$
それを再帰的に行うから、$`O(n\log n)`$
### クイックソート
安定なアルゴリズムではない。
適切な基準の選び方なら$`O(n\log n)`$
最悪の場合は$`O(n^2)`$
追加のメモリを使わない
### バケットソート(計数ソート) 要復習
1~kの配列に出現する数を記録してから、累積和を求める。
元の配列を後ろから走査し、その値が記録されている累積和のところを見る。
累積和の値が新しい出力のindexとなる。

安定。$`O(n+k)`$
### 基数ソート
配列の各要素について順番にi桁目ごとを比較し並び替える。
それをiに対して1...k桁目に全て行う。
安定(そうでないと一桁前のソートの順序が保持できない)
$`O(nk),k`$はソートする対象の桁数

## データ構造

### 配列
追加する時は、配列の後ろに空きを確保してから一個ずつずらす。
各データに直接アクセスできることを**ランダムアクセス**という。
### リスト
### スタック(プッシュダウンスタック)
情報を取り出す時には、最も後で入れられたものを取り出す。

配列を用意してデータが追加された時にはtop++をしてA[top]に入れる
データを取り出す時にはA[top]を取り出してtop--をする。

### キュー
データを取り出す時に最も古いものを取り出す。
円環状になった配列Aを用意する。そして、先頭headと最後尾tailを指すindexを用意する。
データを追加する際には最後尾tail++してA[tail]にいれる。
データを取り出す際にはA[head]を取り出して、先頭head++する。

### ハッシュテーブル
ハッシュ探索は、要素の追加も削除も探索も、すべて O(1) で行える
#### ハッシュ関数
ハッシュ関数は、結果がばらける、高速に行うことができる、
#### オープンアドレス法(開拓番地法)
衝突が起こった時に別のバケットを探しそこにデータを格納する
メモリの面でチェイン法より優れている
- 線形走査法
最初に全てのバケットにEMPTYを入れる
衝突が起こったら一つ次のバケットを参照する。
削除の時には特殊文字DELを挿入する

かたまりができると性能が落ちてしまう。
- 二重ハッシュ法
衝突が起こった場所から、もう一度ハッシュ関数を使い、その値の距離だけ離れたバケットに入れる

####  チェイン法
デーブルの一つに連結リストを使う。

## 木
### 木を表すデータ構造
### 二分探索木
左の子孫の値 ≤ 親の値 ≤ 右の子孫の値
を満たす二分木
一回の探索、挿入は平均$`O(\log n)`$最悪で`$O(n)`
in-place orderで二分探索木を走査すると$`O(n)`$でソートできる。二分探索木を構成するのに$`O(n\log n)`$かかるから、
ソートには$`O(n\log n)`$の計算量となる。安定

元のデータが昇順や降順である場合、偏った二分木にってしまう。
### ヒープ(グラフ)
子孫の値 ≤ 親の値 を必ず満たす、**平衡二分木**
- 挿入
平衡二分木なので、一番右下に挿入する。そして親と比較し、ヒープの条件が満たされるまで親と交換する。$`O(\log n)`$
- 根ノードの取り出し
根ノードを取り出す。その後根ノードがあった場所に、一番右下のノードを移す。そして、*ヒープが維持されていなければ下の左と右の子で大きい方と交換する。*
*太字*を繰り返す。$`O(\log n)`$


### 平衡木
### [AVL木](https://daeudaeu.com/avl_tree/)
### b木(B+木)
多分木の平衡木(バランス木)である

**制約**
- 根ノードは最大で2m+1個のポインタと2m個のキーを交互に収容している。
- 中間ノードは最小でm個以上の探索キー、m+1個のポインタ、最大で2m個のキー、2m+1のポインタをもつ
- 葉ノードは必ず一つ以上のキーをもつ。
- 根ノードから葉ノードまでの距離は全て一定である

自然数mをB木のオーダーと呼ぶ(オーダーmのB木)

**挿入**
1. 探索を行い、葉ノードに空きがあれば、そのノードに挿入して終わる。
2. 空きがない場合は兄弟となる新しいノードを増やし二分割して入れる。
3. 親ノードに空きがあれば、中間の値を親ノードに追加し、ポインタをつけなおす。
4. 親ノードに空きがない場合(2m個のデータ)は親ノードの値に子から上がってきた2m+1のデータをm,1,mに分割し、二つのノードにし、1個のデータをさらにその親に回す。
5. 4を再帰的に行う。

**削除**

**葉ノードの場合**
1. 葉ノードに二つ以上のレコードがあるなら,そのまま削除する。
2. ノードに一つしかレコードがない場合はアンダーフローが起こる。
   - 同じ親ノードにぶら下がっているノードから値を持ってきて、親ノードに中間値を置き換える。
   -　別ノードにもってこれる値がない場合、中間値を親ノードから持ってきて、親ノードからその中間値を削除する。

**葉ノード以外の場合**
1. そのノードの値を削除する
2. ノードの子孫の中で最小or最大の値をもってくる
3. 持ってきた値を削除したという扱いで葉ノードを削除した場合を行う。
## グラフ探索
### 幅優先探索
### 深さ優先探索
### 最短経路問題(ベルマンフォード法,ダイクストラ法)
### A*

## 動的計画法
### ナップサック問題
### [最長共通部分系列問題](https://naoya-2.hatenadiary.org/entry/20090328/1238251033)

